/******************************** introduction *********************************/
This file is gnerated by protoc plugin 'protoc-gen-cgi'.

	* cgi-worker xml: 
		- referenced by jungle-web framework
		- put it into ${jungle-web-project}/src/main/resources/META-INF/worker

	* cgi-service java class:
		- referenced by your own java code in jungle-web project
		- put it into ${jungle-web-project/src/main/.../...}

	* usage:
		- invoking protoc with params '--cgi_out=dir', only cgi-worker xml is generated
		- invoking protoc with params '--cgi_out=plugins=service:dir', both cgi-worker xml and cgi-service java class are gnerated
/******************************** cgi-worker xml *********************************/

<?xml version="1.0" encoding="UTF-8"?>
<cgi-project name="{cgi_project_name}">

	// method index: 0
	<ilive name="CallTestInterface1" id="1"
		workname="" l5Modid="xxxx" l5Cmdid="yyy"
		testL5Modid="" testL5Cmdid="" cmd="1" subCmd="1"
		timeout="2000" tryAgain="true"
		reqProtoClazz="test.TestReq1"
		rspProtoClazz="test.TestRsp1"
		contacter="zzz" desc="..." pbResult="true">
	</ilive>

	// method index: 1
	<ilive name="CallTestInterface2" id="2"
		workname="" l5Modid="xxxx" l5Cmdid="yyy"
		testL5Modid="" testL5Cmdid="" cmd="1" subCmd="2"
		timeout="2000" tryAgain="true"
		reqProtoClazz="test.TestReq2"
		rspProtoClazz="test.TestRsp2"
		contacter="zzz" desc="..." pbResult="true">
	</ilive>

</cgi-project>
/******************************** cgi-service xml *********************************/

// This file is generated by protoc-gen-cgi, protoc invoked with --cgi_out=plugins=cgiservice:dir
// 
// If any errors found, please email to zhijiezhang@tencent.com to report. Thanks in advance!
// Of course, you can edit the file to meet your needs, but good tips should be shared, so we can
// make this plugin better and better to accelerate our partners' developing effiency.

/**
 * CgiService Util Class
 * 
 * @author ${whoami}
 * @see    ${proto}
 */
package com.tencent.jungle.now.web.test;

import com.google.inject.Inject;

import com.tencent.jungle.now.web.exec.user.ExchangeUidInfoExecutor;
import com.tencent.jungle.now.web.proto.PBNoble;
import com.tencent.jungle.web.config.CGIContext;
import com.tencent.jungle.web.config.ResourceCGISpecManager;
import com.tencent.jungle.web.config.adapters.CGIServiceAdapter;
import com.tencent.jungle.web.config.beans.CGIExecutorService;
import com.tencent.jungle.web.config.executor.CGIExecutor;

import kilim.Pausable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;

/**
 * GenTestCGIServiceAdapter
 * 
 * ${proto-package-comments}
 * @author ${whoami}
 * @see    ${proto}
 */
class GenTestCGIServiceAdapter {
	
	// class members
	
	// class methods
}



// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ cgiservice.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the cgiservice package it is being compiled against.
const _ = cgiservice.SupportPackageIsVersion4


// Client API for TestSvr service

type TestSvrClient interface {
CallTestInterface1(ctx context.Context, in *TestReq1, opts ...cgiservice.CallOption) (*TestRsp1, error)
CallTestInterface2(ctx context.Context, in *TestReq2, opts ...cgiservice.CallOption) (*TestRsp2, error)
}

type testSvrClient struct {
cc *cgiservice.ClientConn
}

func NewTestSvrClient (cc *cgiservice.ClientConn) TestSvrClient {
return &testSvrClient{cc}
}

func (c *testSvrClient) CallTestInterface1(ctx context.Context, in *TestReq1, opts ...cgiservice.CallOption) (*TestRsp1, error){
out := new(TestRsp1)
err := cgiservice.Invoke(ctx, "/test.TestSvr/CallTestInterface1", in, out, c.cc, opts...)
if err != nil { return nil, err }
return out, nil
}

func (c *testSvrClient) CallTestInterface2(ctx context.Context, in *TestReq2, opts ...cgiservice.CallOption) (*TestRsp2, error){
out := new(TestRsp2)
err := cgiservice.Invoke(ctx, "/test.TestSvr/CallTestInterface2", in, out, c.cc, opts...)
if err != nil { return nil, err }
return out, nil
}

// Server API for TestSvr service

type TestSvrServer interface {
CallTestInterface1(context.Context, *TestReq1) (*TestRsp1, error)
CallTestInterface2(context.Context, *TestReq2) (*TestRsp2, error)
}

func RegisterTestSvrServer(s *cgiservice.Server, srv TestSvrServer) {
s.RegisterService(&_TestSvr_serviceDesc, srv)
}

func _TestSvr_CallTestInterface1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor cgiservice.UnaryServerInterceptor) (interface{}, error) {
in := new(TestReq1)
if err := dec(in); err != nil { return nil, err }
if interceptor == nil { return srv.(TestSvrServer).CallTestInterface1(ctx, in) }
info := &cgiservice.UnaryServerInfo{
Server: srv,
FullMethod: "/test.TestSvr/CallTestInterface1",
}
handler := func(ctx context.Context, req interface{}) (interface{}, error) {
return srv.(TestSvrServer).CallTestInterface1(ctx, req.(*TestReq1))
}
return interceptor(ctx, in, info, handler)
}

func _TestSvr_CallTestInterface2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor cgiservice.UnaryServerInterceptor) (interface{}, error) {
in := new(TestReq2)
if err := dec(in); err != nil { return nil, err }
if interceptor == nil { return srv.(TestSvrServer).CallTestInterface2(ctx, in) }
info := &cgiservice.UnaryServerInfo{
Server: srv,
FullMethod: "/test.TestSvr/CallTestInterface2",
}
handler := func(ctx context.Context, req interface{}) (interface{}, error) {
return srv.(TestSvrServer).CallTestInterface2(ctx, req.(*TestReq2))
}
return interceptor(ctx, in, info, handler)
}

var _TestSvr_serviceDesc = cgiservice.ServiceDesc {
ServiceName: "test.TestSvr",
HandlerType: (*TestSvrServer)(nil),
Methods: []cgiservice.MethodDesc{
{
MethodName: "CallTestInterface1",
Handler: _TestSvr_CallTestInterface1_Handler,
},
{
MethodName: "CallTestInterface2",
Handler: _TestSvr_CallTestInterface2_Handler,
},
},
Streams: []cgiservice.StreamDesc{
},
Metadata: "Test.proto",
}

